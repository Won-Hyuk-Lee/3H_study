# 2. C# 기초 및 메모리 구조 (심화)

## 1. 필수 용어 상세 설명

### ① 클래스 vs 객체 vs 인스턴스 (붕어빵 비유)
이 세 가지는 비슷해 보이지만 명확한 차이가 있습니다.

*   **클래스 (Class)**: **설계도**.
    *   "붕어빵 틀" 그 자체입니다.
    *   실제 먹을 수 있는 붕어빵이 아닙니다. 그냥 쇠로 된 틀입니다.
    *   코드 상에 `class Monster { ... }` 라고 적혀있는 텍스트 덩어리입니다.
*   **객체 (Object)**: **구현할 대상**.
    *   "붕어빵"이라는 개념입니다.
    *   아직 세상에 나오지 않았을 수도 있고, 나올 수도 있는 추상적인 의미가 강합니다.
*   **인스턴스 (Instance)**: **실체**.
    *   틀(Class)에 반죽을 부어 구워내서 **실제 메모리(Heap)에 생성된** 붕어빵입니다.
    *   `new Monster();`를 하는 순간 인스턴스가 됩니다.
    *   우리는 이 인스턴스를 조작해서 게임을 만듭니다.

```csharp
// [클래스] 설계도
public class Monster 
{
    public int hp;
}

void Start() 
{
    // m1은 "참조 변수" (리모컨)
    // new Monster()가 실행될 때 비로소 "인스턴스"가 힙 메모리에 생성됨
    Monster m1 = new Monster(); 
}
```

### ② 델리게이트 (Delegate) - 대리자
함수를 변수처럼 다루는 기능입니다.
*   **기본 개념**: "나 대신 이 함수 좀 실행해줘" 하고 함수를 건네주는 것.
*   **왜 쓰는가?**: 콜백(Callback) 구현, 이벤트 시스템, 유연한 설계.

**예시: 버튼 클릭 시 실행할 행동을 전달**
```csharp
// 1. 델리게이트 선언 (함수 족보: 반환형 void, 매개변수 없음)
public delegate void ButtonClickAction();

public class Button 
{
    // 2. 델리게이트 변수 생성 (함수를 담을 빈 그릇)
    public ButtonClickAction OnClick;

    public void Press() 
    {
        // 3. 버튼이 눌리면 담겨있는 함수를 실행 (누가 담겨있는지 난 모름)
        if (OnClick != null) 
            OnClick();
    }
}

// 사용 예시
void Start() 
{
    Button btn = new Button();
    // 함수를 변수처럼 집어넣음! (괄호() 없음 주의)
    btn.OnClick = OpenInventory; 
    
    btn.Press(); // OpenInventory가 실행됨
}

void OpenInventory() { Console.WriteLine("인벤토리 열림"); }
```

---

## 2. 메모리 영역 (Memory Layout) 상세
프로그램이 실행되면 OS는 메모리를 4등분해서 관리합니다.

### ① 코드 (Code)
*   우리가 짠 소스 코드가 기계어로 번역되어 저장됨.
*   **특징**: 읽기 전용 (수정 불가).

### ② 데이터 (Data)
*   **저장 대상**: `static` 변수, 전역 변수.
*   **생명 주기**: 프로그램 시작 시 생성 ~ 프로그램 종료 시 삭제.
*   **주의**: 게임 내내 메모리를 차지하므로, 너무 큰 데이터를 static으로 잡으면 메모리 낭비.
*   **싱글턴**이 바로 이 영역(정확히는 static 변수가 가리키는 참조)을 활용함.

### ③ 힙 (Heap) - "자유 저장소"
*   **저장 대상**: `new`로 생성된 모든 것 (클래스 인스턴스, 배열, 리스트 등).
*   **특징**:
    *   개발자가 원할 때 만들고, (C++에선) 원할 때 지움.
    *   C#은 **Garbage Collector (GC)**가 주기적으로 청소함.
    *   메모리 구조가 복잡해서 스택보다 접근 속도가 약간 느림.
    *   **참조 타입(Reference Type)**이 사는 곳.

### ④ 스택 (Stack) - "작업장"
*   **저장 대상**: 지역 변수, 매개 변수, 리턴 값.
*   **특징**:
    *   함수가 호출될 때 쌓이고(Push), 끝나면 바로 사라짐(Pop).
    *   매우 빠르고 효율적.
    *   **값 타입(Value Type)**이 사는 곳.

---

## 3. 값 타입 vs 참조 타입 (핵심 심화)
메모리에 어떻게 저장되는지가 다릅니다.

### 상황: 변수를 다른 변수에 대입할 때 (`b = a`)

#### 1. 값 타입 (Value Type) : `int`, `float`, `struct`, `bool`
*   **복사 방식**: 내용물(값) 자체를 복사.
*   **결과**: 원본과 사본은 **완전히 남남**.

```csharp
int a = 10;
int b = a; // 10이라는 값을 복사해서 b에 넣음.
b = 20;    // b만 20이 됨.

Console.WriteLine(a); // 10 (원본 유지)
```

#### 2. 참조 타입 (Reference Type) : `class`, `string`, `array`, `delegate`
*   **복사 방식**: 힙 영역의 **주소(참조)**만 복사. (바로가기 아이콘 복사)
*   **결과**: 원본과 사본이 **같은 놈을 가리킴**.

```csharp
class Monster { public int hp; }

Monster m1 = new Monster();
m1.hp = 100;

Monster m2 = m1; // m1이 가리키는 주소를 m2에게 줌. (둘 다 같은 몬스터를 봄)
m2.hp = 50;      // m2를 통해 hp를 깎음.

Console.WriteLine(m1.hp); // 50 (m1도 같이 깎여있음! 중요!)
```

> **비유**:
> *   **값 타입**: 엑셀 파일을 복사해서 친구에게 줌. 친구가 수정해도 내 파일은 그대로.
> *   **참조 타입**: 구글 스프레드시트 링크를 친구에게 줌. 친구가 수정하면 내 화면에서도 바뀜.
